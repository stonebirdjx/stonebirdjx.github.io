[{"content":"go build 过程 go build 参数说明\n-a\t将命令源码文件与库源码文件全部重新构建，即使是最新的 -n\t把编译期间涉及的命令全部打印出来，但不会真的执行，非常方便我们学习 -race\t开启竞态条件的检测，支持的平台有限制 -x\t打印编译期间用到的命名，它与 -n 的区别是，它不仅打印还会执行 go build -n main.go\nE:\\SomeFile\\gospace\\helloworld\u0026gt;go build -n main.go ... \u0026#34;C:\\\\Program Files\\\\Go\\\\pkg\\\\tool\\\\windows_amd64\\\\compile.exe\u0026#34; -o \u0026#34;$WORK\\\\b001\\\\_pkg_.a\u0026#34; -trimpath \u0026#34;$WORK\\\\b001=\u0026gt;\u0026#34; -p main -complete -buildid v3BL3MHm16Q3kjspXXCg/v3BL3MHm16Q3kjspXXCg -goversion go1.18.2 -c=4 -nolocalimports -importcfg \u0026#34;$WORK\\\\b001\\\\importcfg\u0026#34; -pack ... \u0026#34;C:\\\\Program Files\\\\Go\\\\pkg\\\\tool\\\\windows_amd64\\\\buildid.exe\u0026#34; -w \u0026#34;$WORK\\\\b001\\\\_pkg_.a\u0026#34; # internal ... \u0026#34;C:\\\\Program Files\\\\Go\\\\pkg\\\\tool\\\\windows_amd64\\\\link.exe\u0026#34; -o \u0026#34;$WORK\\\\b001\\\\exe\\\\a.out.exe\u0026#34; -importcfg \u0026#34;$WORK\\\\b001\\\\importcfg.link\u0026#34; -buildmode=pie -buildid=qEvHouU39HqKxAChmahv/v3BL 3MHm16Q3kjspXXCg/v3BL3MHm16Q3kjspXXCg/qEvHouU39HqKxAChmahv -extld=gcc \u0026#34;$WORK\\\\b001\\\\_pkg_.a\u0026#34; 这一部分是编译的核心，通过 compile、 buildid、 link 三个命令会编译出可执行文件 a.out。\n然后通过 mv 更换成最终名字\n流程图 Go 语言编译器的源代码在 src/cmd/compile 目录中，目录下的文件共同组成了 Go 语言的编译器。\n编译器分前后端\n前端一般承担着词法分析、语法分析、语义分析（类型检查）。\n后端主要负责 中间码生成、目标代码优化，机器码生成。\n语法分析 源代码在计算机眼里其实是一团乱麻，一个由字符组成的、无法被理解的字符串，所有的字符在计算器看来并没有什么区别。词法分析简单来说就是将我们写的源代码翻译成 Token\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;go/scanner\u0026#34; \u0026#34;go/token\u0026#34; ) func main() { src := []byte(` package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, bytedance!\u0026#34;) } `) var s scanner.Scanner fset := token.NewFileSet() file := fset.AddFile(\u0026#34;\u0026#34;, fset.Base(), len(src)) s.Init(file, src, nil, 0) for { pos, tok, lit := s.Scan() fmt.Printf(\u0026#34;%-6s%-8s%q\\n\u0026#34;, fset.Position(pos), tok, lit) if tok == token.EOF { break } } } 输出\n2:1 package \u0026#34;package\u0026#34; 2:9 IDENT \u0026#34;main\u0026#34; 2:13 ; \u0026#34;\\n\u0026#34; 4:1 import \u0026#34;import\u0026#34; 4:8 STRING \u0026#34;\\\u0026#34;fmt\\\u0026#34;\u0026#34; 4:13 ; \u0026#34;\\n\u0026#34; 6:1 func \u0026#34;func\u0026#34; 6:6 IDENT \u0026#34;main\u0026#34; 6:10 ( \u0026#34;\u0026#34; 6:11 ) \u0026#34;\u0026#34; 6:13 { \u0026#34;\u0026#34; 7:5 IDENT \u0026#34;fmt\u0026#34; 7:8 . \u0026#34;\u0026#34; 7:9 IDENT \u0026#34;Println\u0026#34; 7:16 ( \u0026#34;\u0026#34; 7:17 STRING \u0026#34;\\\u0026#34;Hello, bytedance!\\\u0026#34;\u0026#34; 7:36 ) \u0026#34;\u0026#34; 7:37 ; \u0026#34;\\n\u0026#34; 8:1 } \u0026#34;\u0026#34; 8:2 ; \u0026#34;\\n\u0026#34; 8:3 EOF \u0026#34;\u0026#34; 语法分析（抽象语法树） 语法分析是拿到Token，它将作为语法分析器的输入。然后经过处理后生成 AST 结构作为输出。\n所谓的语法分析就是将 Token 转化为可识别的程序语法结构，而 AST 就是这个语法的抽象表示。构造这颗树有两种方法。\n​\t1、自上而下 这种方式会首先构造根节点，然后就开始扫描 Token，遇到 STRING 或者其它类型就知道这是在进行类型申明，func 就表示是函数申明。就这样一直扫描直到程序结束。\n​\t2、自下而上 这种是与上一种方式相反的，它先构造子树，然后再组装成一颗完整的树。\npackage main import ( \u0026#34;go/ast\u0026#34; \u0026#34;go/parser\u0026#34; \u0026#34;go/token\u0026#34; \u0026#34;log\u0026#34; ) func main() { src := []byte(` package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, bytedance!\u0026#34;) } `) fset := token.NewFileSet() file, err := parser.ParseFile(fset, \u0026#34;\u0026#34;, src, 0) if err != nil { log.Fatal(err) } ast.Print(fset, file) } ATS\n0 *ast.File { 1 . Package: 2:1 2 . Name: *ast.Ident { 3 . . NamePos: 2:9 4 . . Name: \u0026#34;main\u0026#34; 5 . } 6 . Decls: []ast.Decl (len = 2) { 7 . . 0: *ast.GenDecl { 8 . . . TokPos: 4:1 9 . . . Tok: import 10 . . . Lparen: - 11 . . . Specs: []ast.Spec (len = 1) { 12 . . . . 0: *ast.ImportSpec { 13 . . . . . Path: *ast.BasicLit { 14 . . . . . . ValuePos: 4:8 15 . . . . . . Kind: STRING 16 . . . . . . Value: \u0026#34;\\\u0026#34;fmt\\\u0026#34;\u0026#34; 17 . . . . . } 18 . . . . . EndPos: - 19 . . . . } 20 . . . } 21 . . . Rparen: - 22 . . } 23 . . 1: *ast.FuncDecl { 24 . . . Name: *ast.Ident { 25 . . . . NamePos: 6:6 26 . . . . Name: \u0026#34;main\u0026#34; 27 . . . . Obj: *ast.Object { 28 . . . . . Kind: func 29 . . . . . Name: \u0026#34;main\u0026#34; 30 . . . . . Decl: *(obj @ 23) 31 . . . . } 32 . . . } 33 . . . Type: *ast.FuncType { 34 . . . . Func: 6:1 35 . . . . Params: *ast.FieldList { 36 . . . . . Opening: 6:10 37 . . . . . Closing: 6:11 38 . . . . } 39 . . . } 40 . . . Body: *ast.BlockStmt { 41 . . . . Lbrace: 6:13 42 . . . . List: []ast.Stmt (len = 1) { 43 . . . . . 0: *ast.ExprStmt { 44 . . . . . . X: *ast.CallExpr { 45 . . . . . . . Fun: *ast.SelectorExpr { 46 . . . . . . . . X: *ast.Ident { 47 . . . . . . . . . NamePos: 7:5 48 . . . . . . . . . Name: \u0026#34;fmt\u0026#34; 49 . . . . . . . . } 50 . . . . . . . . Sel: *ast.Ident { 51 . . . . . . . . . NamePos: 7:9 52 . . . . . . . . . Name: \u0026#34;Println\u0026#34; 53 . . . . . . . . } 54 . . . . . . . } 55 . . . . . . . Lparen: 7:16 56 . . . . . . . Args: []ast.Expr (len = 1) { 57 . . . . . . . . 0: *ast.BasicLit { 58 . . . . . . . . . ValuePos: 7:17 59 . . . . . . . . . Kind: STRING 60 . . . . . . . . . Value: \u0026#34;\\\u0026#34;Hello, bytedance!\\\u0026#34;\u0026#34; 61 . . . . . . . . } 62 . . . . . . . } 63 . . . . . . . Ellipsis: - 64 . . . . . . . Rparen: 7:36 65 . . . . . . } 66 . . . . . } 67 . . . . } 68 . . . . Rbrace: 8:1 69 . . . } 70 . . } 71 . } 72 . Scope: *ast.Scope { 73 . . Objects: map[string]*ast.Object (len = 1) { 74 . . . \u0026#34;main\u0026#34;: *(obj @ 27) 75 . . } 76 . } 77 . Imports: []*ast.ImportSpec (len = 1) { 78 . . 0: *(obj @ 12) 79 . } 80 . Unresolved: []*ast.Ident (len = 1) { 81 . . 0: *(obj @ 46) 82 . } 83 } gofmt的原理就是先转抽象语法树，再转回代码\n语义分析（类型检查） AST 生成后，语义分析将使用它作为输入，并且的有一些相关的操作也会直接在这颗树上进行改写。\n首先就是 Golang 文档中提到的会进行类型检查，还有类型推断，查看类型是否匹配，是否进行隐式转化（go 没有隐式转化）。\n第一步是进行名称检查和类型推断，签定每个对象所属的标识符，以及每个表达式具有什么类型。类型检查也还有一些其它的检查要做，像“声明未使用”以及确定函数是否中止。\n我们常常在 debug 代码的时候，需要禁止内联，其实就是操作的这个阶段。\n# 编译的时候禁止内联 go build -gcflags \u0026#39;-N -l\u0026#39; -N 禁止编译优化 -l 禁止内联,禁止内联也可以一定程度上减小可执行程序大小 中间码生成（适应平台，重用代码） 然已经拿到 AST，机器运行需要的又是二进制。为什么不直接翻译成二进制呢？其实到目前为止从技术上来说已经完全没有问题了。\n但是，我们有各种各样的操作系统，有不同的 CPU 类型，每一种的位数可能不同；寄存器能够使用的指令也不同，像是复杂指令集与精简指令集等；在进行各个平台的兼容之前，我们还需要替换一些底层函数，比如我们使用 make 来初始化 slice，此时会根据传入的类型替换为：makeslice64 或者 makeslice。当然还有像 painc、channel 等等函数的替换也会在中间码生成过程中进行替换。\n中间码存在的另外一个价值是提升后端编译的重用，比如我们定义好了一套中间码应该是长什么样子，那么后端机器码生成就是相对固定的。每一种语言只需要完成自己的编译器前端工作即可。这也是大家可以看到现在开发一门新语言速度比较快的原因。编译是绝大部分都可以重复使用的。\n而且为了接下来的优化工作，中间代码存在具有非凡的意义。因为有那么多的平台，如果有中间码我们可以把一些共性的优化都放到这里。\n中间码也是有多种格式的，像 Golang 使用的就是 SSA 特性的中间码(IR)，这种形式的中间码，最重要的一个特性就是最在使用变量之前总是定义变量，并且每个变量只分配一次。\n代码优化 在 go 的编译文档中，我并没找到独立的一步进行代码的优化。不过根据我们上面的分析，可以看到其实代码优化过程遍布编译器的每一个阶段。大家都会力所能及的做些事情。\n通常我们除了用高效代码替换低效的之外，还有如下的一些处理：\n并行性，充分利用现在多核计算机的特性 流水线，cpu 有时候在处理 a 指令的时候，还能同时处理 b 指令 指令的选择，为了让 cpu 完成某些操作，需要使用指令，但是不同的指令效率有非常大的差别，这里会进行指令优化 利用寄存器与高速缓存，我们都知道 cpu 从寄存器取是最快的，从高速缓存取次之。这里会进行充分的利用 机器码生成 经过优化后的中间代码，首先会在这个阶段被转化为汇编代码（Plan9），而汇编语言仅仅是机器码的文本表示，机器还不能真的去执行它。所以这个阶段会调用汇编器，汇编器会根据我们在执行编译时设置的架构，调用对应代码来生成目标机器码。\n这里比有意思的是，Golang 总说自己的汇编器是跨平台的。其实他也是写了多分代码来翻译最终的机器码。因为在入口的时候他会根据我们所设置的 GOARCH=xxx 参数来进行初始化处理，然后最终调用对应架构编写的特定方法来生成机器码。这种上层逻辑一致，底层逻辑不一致的处理方式非常通用，非常值得我们学习。我们简单来一下这个处理。\n首先看入口函数 cmd/compile/main.go:main()\nvar archInits = map[string]func(*gc.Arch){ \u0026#34;386\u0026#34;: x86.Init, \u0026#34;amd64\u0026#34;: amd64.Init, \u0026#34;amd64p32\u0026#34;: amd64.Init, \u0026#34;arm\u0026#34;: arm.Init, \u0026#34;arm64\u0026#34;: arm64.Init, \u0026#34;mips\u0026#34;: mips.Init, \u0026#34;mipsle\u0026#34;: mips.Init, \u0026#34;mips64\u0026#34;: mips64.Init, \u0026#34;mips64le\u0026#34;: mips64.Init, \u0026#34;ppc64\u0026#34;: ppc64.Init, \u0026#34;ppc64le\u0026#34;: ppc64.Init, \u0026#34;s390x\u0026#34;: s390x.Init, \u0026#34;wasm\u0026#34;: wasm.Init, } func main() { // 从上面的map根据参数选择对应架构的处理 archInit, ok := archInits[objabi.GOARCH] if !ok { ...... } // 把对应cpu架构的对应传到内部去 gc.Main(archInit) } 然后在 cmd/internal/obj/plist.go 中调用对应架构的方法进行处理\nfunc Flushplist(ctxt *Link, plist *Plist, newprog ProgAlloc, myimportpath string) { ... ... for _, s := range text { mkfwd(s) linkpatch(ctxt, s, newprog) // 对应架构的方法进行自己的机器码翻译 ctxt.Arch.Preprocess(ctxt, s, newprog) ctxt.Arch.Assemble(ctxt, s, newprog) linkpcln(ctxt, s) ctxt.populateDWARF(plist.Curfn, s, myimportpath) } } 整个过程下来，可以看到编译器后端有很多工作需要做的，你需要对某一个指令集、cpu 的架构了解，才能正确的进行翻译机器码。同时不能仅仅是正确，一个语言的效率是高还是低，也在很大程度上取决于编译器后端的优化。特别是即将进入 AI 时代，越来越多的芯片厂商诞生，我估计以后对这方面人才的需求会变得越来越旺盛。\n","permalink":"https://stonebirdjx.github.io/posts/golang/golang%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","summary":"go build 过程 go build 参数说明\n-a\t将命令源码文件与库源码文件全部重新构建，即使是最新的 -n\t把编译期间涉及的命令全部打印出来，但不会真的执行，非常方便我们学习 -race\t开启竞态条件的检测，支持的平台有限制 -x\t打印编译期间用到的命名，它与 -n 的区别是，它不仅打印还会执行 go build -n main.go\nE:\\SomeFile\\gospace\\helloworld\u0026gt;go build -n main.go ... \u0026#34;C:\\\\Program Files\\\\Go\\\\pkg\\\\tool\\\\windows_amd64\\\\compile.exe\u0026#34; -o \u0026#34;$WORK\\\\b001\\\\_pkg_.a\u0026#34; -trimpath \u0026#34;$WORK\\\\b001=\u0026gt;\u0026#34; -p main -complete -buildid v3BL3MHm16Q3kjspXXCg/v3BL3MHm16Q3kjspXXCg -goversion go1.18.2 -c=4 -nolocalimports -importcfg \u0026#34;$WORK\\\\b001\\\\importcfg\u0026#34; -pack ... \u0026#34;C:\\\\Program Files\\\\Go\\\\pkg\\\\tool\\\\windows_amd64\\\\buildid.exe\u0026#34; -w \u0026#34;$WORK\\\\b001\\\\_pkg_.a\u0026#34; # internal ... \u0026#34;C:\\\\Program Files\\\\Go\\\\pkg\\\\tool\\\\windows_amd64\\\\link.exe\u0026#34; -o \u0026#34;$WORK\\\\b001\\\\exe\\\\a.out.exe\u0026#34; -importcfg \u0026#34;$WORK\\\\b001\\\\importcfg.link\u0026#34; -buildmode=pie -buildid=qEvHouU39HqKxAChmahv/v3BL 3MHm16Q3kjspXXCg/v3BL3MHm16Q3kjspXXCg/qEvHouU39HqKxAChmahv -extld=gcc \u0026#34;$WORK\\\\b001\\\\_pkg_.a\u0026#34; 这一部分是编译的核心，通过 compile、 buildid、 link 三个命令会编译出可执行文件 a.out。\n然后通过 mv 更换成最终名字","title":"Golang编译原理"},{"content":"","permalink":"https://stonebirdjx.github.io/posts/golang/helloworld/","summary":"","title":"Go hello"},{"content":"测试blog hello,world package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, world\u0026#34;) fmt.Println(\u0026#34;Hello, 世界\u0026#34;) } 小故事 一只山鹰和一只狐狸成为好朋友，它们决定住在一起，相互照应。于是它们找到一棵大树，山鹰飞到树上筑起了鸟巢，狐狸走到树下的灌木丛中造了一个窝。一天天过去了，山鹰产下了几颗蛋，坐在鸟巢里孵蛋，狐狸也生下了几只幼仔，躺在窝里喂小狐狸。\n这天，狐狸出去找吃的，留下小狐狸独自在家，山鹰肚子饿了，它懒得到很远的地方去找吃的，就飞到灌木丛中把小狐狸全吃掉了。\n狐狸回来发现小狐狸被吃了，又伤心又愤怒，可是山鹰住在树上，狐狸爬不上树，它没法找山鹰报仇。\n过了一段时间，小山鹰出世了，山鹰离开鸟巢去给孩子们找吃的。山鹰运气好，碰到一群人在烤羊肉，山鹰从空中飞下去，抓起带着火的羊肉飞回了巢里。\n一阵风吹来，羊肉上面的火星点燃了巢里的枯草和树枝。鸟巢燃了起来，熊熊大火把鸟巢烧得精光，小鹰也被烧死了，并从树上掉下来。树下的狐狸看到后急忙跑上前把小鹰全吃了。\n山鹰背信弃义伤害了自己的朋友，最后自己也得到了惩罚。\n","permalink":"https://stonebirdjx.github.io/posts/my-first-post/","summary":"测试blog hello,world package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, world\u0026#34;) fmt.Println(\u0026#34;Hello, 世界\u0026#34;) } 小故事 一只山鹰和一只狐狸成为好朋友，它们决定住在一起，相互照应。于是它们找到一棵大树，山鹰飞到树上筑起了鸟巢，狐狸走到树下的灌木丛中造了一个窝。一天天过去了，山鹰产下了几颗蛋，坐在鸟巢里孵蛋，狐狸也生下了几只幼仔，躺在窝里喂小狐狸。\n这天，狐狸出去找吃的，留下小狐狸独自在家，山鹰肚子饿了，它懒得到很远的地方去找吃的，就飞到灌木丛中把小狐狸全吃掉了。\n狐狸回来发现小狐狸被吃了，又伤心又愤怒，可是山鹰住在树上，狐狸爬不上树，它没法找山鹰报仇。\n过了一段时间，小山鹰出世了，山鹰离开鸟巢去给孩子们找吃的。山鹰运气好，碰到一群人在烤羊肉，山鹰从空中飞下去，抓起带着火的羊肉飞回了巢里。\n一阵风吹来，羊肉上面的火星点燃了巢里的枯草和树枝。鸟巢燃了起来，熊熊大火把鸟巢烧得精光，小鹰也被烧死了，并从树上掉下来。树下的狐狸看到后急忙跑上前把小鹰全吃了。\n山鹰背信弃义伤害了自己的朋友，最后自己也得到了惩罚。","title":"My First Post"},{"content":"","permalink":"https://stonebirdjx.github.io/tags/","summary":"tags","title":"Tags"}]